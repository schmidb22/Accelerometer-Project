# Accelerometer Project üìê

## System Overview

### Transducer and Input
The input to the system is the voltage signal received by the transducer. The transducer used in this project is an accelerometer. An accelerometer is a device that senses acceleration. An application of this device is the use as a tilt sensor, where it converts the angle it is held at to a voltage signal. The accelerometer requires an input of 3.3V in order to run, and outputs the measured angle as a voltage signal. The accelerometer used in our design is capable of measuring acceleration in three dimensions; however, for the purpose of this project only one dimension was used as input. The accelerometer used is ADXL337, it uses capacitance in order to convert the physical changes into an electrical signal. A capacitor is two parallel plates that are separated by an insulator which is capable of storing electric charge. This is used in the accelerometer because when an accelerative force moves one of the parallel plates, it changes the capacitance which can then be converted into voltage.

### Hardware
The hardware used in the project is the EsduinoXtreme, which is a type of microcontroller. A microcontroller is a small computer used for a single integrated circuit. They are often used in automatically controlled products and devices. The Esduino contains an integrated processor (CPU), memory, input/output peripherals, an analog to digital converter, and serial communication capabilities. The Esduino was chosen as the hardware for this project because it contains all of the required components of the project.

The EsduinoXtreme contains an 8MHz crystal, a bus speed of 24MHz and a 1MHz internal oscillator. It operates at either 5V or 3.3V, for this project our device operated at 3.3V because that was the voltage required by the accelerometer. The Esduino has three different types of memory, it can store 240K flash, 4K EEPROM and 11K RAM. Flash memory is non-volatile, random access memory. EEPROM is similar to flash; however, it is capable of erasing a single byte of memory, whereas flash memory can only erase a sector of memory at a time. RAM stands for random access memory, and it is faster than flash and EEPROM. RAM is volatile memory which means it is not permanent, and when the device is turned off the RAM loses all of its data.

The Esduino contains built in 12-bit analog to digital conversion capability. The Esduino contain 6 ADC channels, and this project used channel 6 at a resolution of 12. The Esduino can be programmed using several programs: C, assembly and BASIC. For this project, the Esduino was programmed using C in CodeWarrior. An EsduinoXtreme can be purchased for approximately $85 CAD.

### Program
The Esduino was programmed using CodeWarrior in C. The purpose of the program was to stop and start the code using a push button, switch between display modes, and output to a PC using serial communication. The program began by defining the necessary variables, configuring input and output, setting the baud rate, setting serial communication, and initializing the functions. There were five functions used in this program: one to set the E-clock, one for a delay, and three for the different display modes.

The function offmode() was used when the program was turned off, and it turned all the LEDs off by assigning the output ports to low. In mode1(), the outputted data was represented in binary coded decimal where the first four LEDs represented most significant digit of the angle, the next four LEDs represent the least significant digit of the angle, and the last LED is ignored. This was done by taking the binary value of the angle and using a mask to isolate the values required to output for the least significant and most significant digit of the angle. The values were then bitwise shifted to correspond with the required pins for output. In mode2(), the outputted data was represented by a linear bar in increasing ten-degree increments. This was accomplished by using nine if statements and setting the corresponding LEDs for the range that the angle fell into. These different modes were controlled in the program using different conditions.

The conditions were set as discussed above, including a variable enable to be set to one, then the program was executed in an infinite for loop. The first condition in the code was to check if the push button was pressed. If the button was pressed and enable was set to 1, then the enable would be changed to zero and the program would execute offmode(), send the string ‚ÄúDevice on Standby‚Äù to the PC, and stop sending information through serial communication. The program was able to tell if the push button had been pushed by receiving input from PM0, then using a debounce to make sure that the button had been pressed. The program would stay in offmode() until the button was pushed again, where now the enable was equal to 0 and was changed to 1. The program would output the string ‚ÄúDevice Ready‚Äù, then recommence sending data through serial communication. When the program was on, it would decide between mode0() and mode1() by using another condition statement. The program would use a switch connected to PM1 to determine if the switch was on or off. If the switch was set off, then the program would execute mode0(), and if the switch was on, then the program would execute mode1(). The method used in this program to check these conditions was a polling method. This means that the Esduino continuously checks for changes in the inputs by checking what state they are in. The program runs in an infinite loop and therefore never ends.

### Analog to Digital Converter
The data from the accelerometer was able to be computed because of the onboard analog to digital converter (ADC) on the Esduino. The ADC takes the input from the accelerometer as an analog voltage signal, then converts it to a digital binary value. For this project, the ADC ran with a resolution of 12. The ADC converts from analog to digital by using a successive approximation method. Successive approximation takes the analog signal which ranges from 0 to 3.3 volts, and approximates in 4096 steps (2^12). It performs a series of guessing steps that starts form the most significant bit and goes toward the least significant bit. It uses a binary search through all possible quantization levels by either dividing the number by two, by using a bitwise shift, if the converted number is too large or by multiplying by 1.5 if the number is too small until it converges onto the desired digital output. Using a resolution of 12 is a very accurate way of converting the information because it allows for more precise calculations, and a smaller margin for error.

The accelerometer has a sampling rate of 500Hz, meaning that it sends a new voltage signal to the analog to digital converter every 0.002 seconds. According to the Nyquist theorem, we must sample this data at a frequency of at least 2 x 500Hz in order to avoid aliasing. However, our program is not able to sample at a frequency that fast, so our program instead samples at a frequency of 323Hz. This is the fastest that we can sample while the program functions as desired. However, it is not physically possible to move the accelerometer at a frequency that fast, therefore although new data is being sent every 0.002 seconds, the data is changing much slower, and therefore it is possible for our device to give an accurate result while we are not sampling at the required frequency according to the Nyquist theorem.

### Serial Communication
Once the inputted data from the accelerometer had been converted to a digital signal, it was transmitted to a PC using serial communication. Serial communication is the process of sending data one bit at a time, in order, over a communication channel. For the purposes of this project we chose to communicate at a baud rate of 19200. The baud rate is the rate at which information is transferred, so our serial port transferred 19200 bits of information per second. We chose this baud rate because we wanted to maximize the speed of serial communication, but still maintain accuracy. Higher baudrates correlate with higher error because, as seen in the following formula, baud divisor = bus clock/16*baudrate, serial communication uses a baud divisor, which must be an integer and cannot contain decimal points. When serial communication uses a higher baudrate, the rounding from the baud divisor becomes a much bigger contribution towards error. With that in mind, we chose a baudrate of 19200 because it only has an error of 1.72% whereas if the baudrate was increased to 38400, the error would have been higher than 3% which would have had a negative impact on the accuracy of our output.

When we send the angle to the PC, we are sending it bit by bit, with a start bit and a stop bit. The start and stop bits tell the PC what group of ones and zeros belong together to recreate the data that was sent. The data is then sent starting with the start bit, then sending the least significant bit of data first and the most significant bit last, then ending with the stop bit. Since we are using a resolution of 12, the data must be split into two because the Esduino can only send 8 bits at a time.

We were able to use serial communication to transmit our angle as an integer between 0 and 90. The data is transmitted as characters using ASCII values, and therefore is received by the PC as a string, where it was then interpreted by the computer to display the data.

### PC Program
Once we were able to transmit our calculated angle to the PC, we then displayed the data on a graph in real time using MATLAB. In order for the Esduino to communicate to MATLAB through serial communication, we specified what port we were collecting the information from, which was port 4 for this project. We also set the baudrate to correspond with the baudrate in CodeWarrior, or else MATLAB would not have been able to process the information. Lastly, we had to open serial communication using the fopen built in function. We then created a figure and specified the required axes and labels. We also initialized an array of zeros to store the output data into. We were then able to graph the incoming data onto our figure by using the plot function in a for loop. In the for loop, using the fscanf function we were able to access the incoming data, and then we saved it to an indexed location in the output array. We then plotted that piece of data with the corresponding time in seconds onto the figure and then had the program pause for one second. This allowed the information to be displayed on the graph slowly enough to be able to understand. We were also able to adjust the x axis after 20 seconds to shift right to reveal the new data by resetting the x axis inside the for loop in each iteration. At the end of the for loop, we then displayed all of the data collected in a line graph in order to view all of the data in one graph. We then closed serial communication by using the fclose function. This program is very similar to the polling method used in CodeWarrior.

